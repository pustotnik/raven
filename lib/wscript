#!/usr/bin/env python
# coding=utf8
#

"""
 Copyright (c) 2019, Alexander Magola. All rights reserved.
 license: BSD, see LICENSE for more details.
"""

"""
TODO:
1) Add support to buid any [sub]project/build task. Possible solutions:
- Make own cmdline parsing and ignore WAF cmdline parsing
- Use opt.add_option
- Use some hack: preparse cmdline before WAF cmdline parsing. I can remove posional args that
    WAF won't understand. Overriding or adding own command has no sense
    because I can add extra args to such a command only via opt.add_option.
2) Add support to build tests
3) Env vars like C[XX]FLAGS will have first priority? add support to set such params via environment
and without build type (it's useful for e.g. building distro packages)
4) See waflib/extras/pyqt5.py
"""

import sys, os
import shutil
from copy import deepcopy

_joinpath  = os.path.join
_abspath   = os.path.abspath

from waflib import Configure, Build, Options, Context, Logs

# Avoid writing .pyc files
sys.dont_write_bytecode = True
import buildconf
sys.dont_write_bytecode = False
import assist

#WAF_DIR = Context.waf_dir

confParser = assist.BuildConfParser(buildconf)

# Execute the configuration automatically
Configure.autoconfig = buildconf.waf.get('autoconfig', False)

# WAF detects any our function as command and sometimes we can see them with --help.
# So I decided to make such a 'namespace' to hide them.
class tools:

    @staticmethod
    def makeTargetPath(ctx, dirName, targetName):
        #return _joinpath(targetName)
        return _joinpath(ctx.out_dir, dirName, targetName)

################################################
###    WAF routines
################################################

# these variables are mandatory ('/' are converted automatically)
top = assist.BUILDROOT
out = _joinpath(assist.BUILDROOT, 'out')

# mostly for WAF 'dist' command
APPNAME = buildconf.project['name']
VERSION = buildconf.project['version']

def options(opt):

    # TODO: add support for several builtypes
    #opt.add_option('-b', '--buildtype', action = 'append', choices = confParser.buildTypes(),
    #                default = [confParser.defaultBuildType()],
    #                help = 'set the build type')

    opt.add_option('-b', '--buildtype', action = 'store', choices = confParser.buildTypes(),
                    default = confParser.defaultBuildType(),
                    help = 'set the build type')

    #opt.load('compiler_cxx')

def init(ctx):

    # From optparse documentation: It also means that if the default value is non-empty,
    # the default elements will be present in the parsed value for the option, with any
    # values from the command line appended after those default values.
    # Due to this stupid logic we need to do this:
    if isinstance(Options.options.buildtype, list) and len(Options.options.buildtype) > 1:
        del Options.options.buildtype[0]

    assist.wafcommands = deepcopy(Options.commands)

    buildtype = confParser.realBuildType(Options.options.buildtype)
    for c in (Build.BuildContext, Build.CleanContext, Build.InstallContext, Build.UninstallContext):
        class CtxClass(c):
            variant = buildtype

def configure(ctx):

    assist.useBuldconfInAutoconfig(ctx)

    # See details here: https://gitlab.com/ita1024/waf/issues/1563
    #ctx.env.NO_LOCK_IN_RUN = True

    #TODO: think about:
    #With NO_LOCK_IN_TOP = True this doesn't work:
    ## ./waf/make.py configure
    ## ./waf/make.py build
    ## The project was not configured: run "waf configure" first!
    #BUT this works:
    #./waf/make.py configure build
    # So I can use NO_LOCK_IN_TOP = True if I use 'configure' every time before 'build'
    #ctx.env.NO_LOCK_IN_TOP = True

    #ctx.load('compiler_cxx')

    # make independent copy of root env
    defaultEnv = ctx.env.derive().detach()
    buildtype = confParser.realBuildType(Options.options.buildtype)
    compilerEnv = {}

    def loadCompiler(compiler):
        if compiler not in compilerEnv:
            ctx.setenv(compiler, env = defaultEnv)
            ctx.load(compiler)
            compilerEnv[compiler] = ctx.all_envs[compiler]

    # Examples of setings from environment:
    # CC=clang CXX=clang++
    # CFLAGS=-fsomething LDFLAGS=-Wl,--linker-flag
    if 'CXX' in os.environ:
        loadCompiler(os.environ['CXX'])
    if 'CC' in os.environ:
        loadCompiler(os.environ['CC'])

    for compiler in confParser.compilers(buildtype):
        loadCompiler(compiler)

    # switch to root env due to calls of 'loadCompiler'
    ctx.setenv('')

    ctx.env.alltasks = {}
    tasks = confParser.tasks(buildtype)
    ctx.env.alltasks[buildtype] = tasks

    for taskName, taskParams in tasks.items():
        # make variant for each task: 'buildtype.taskname'
        taskVariant = '%s.%s' % (buildtype, taskName)
        # store it
        taskParams['task-build-env'] = taskVariant

        # set up env each type of compiler for tasks
        parentEnv = defaultEnv
        compiler = taskParams.get('compiler', None)
        if compiler:
            parentEnv = compilerEnv[compiler]
        # and switch to selected env
        ctx.setenv(taskVariant, env = parentEnv)

        # set variables
        assist.setTaskEnvVars(ctx.env, taskParams)

    #ctx.check(header_name='stdio.h', features='cxx cxxprogram', mandatory=False)
    #ctx.check(header_name='cstdio', features='cxx cxxprogram', mandatory=True)

    # Remove unneccesary envs
    for compiler in compilerEnv.keys():
        del ctx.all_envs[compiler]

def build(ctx):

    if ctx.variant is None:
        ctx.fatal('No variant!')

    buildtype = ctx.variant
    if buildtype not in ctx.env.alltasks:
        ctx.fatal("Buildtype '%s' is not found! Step 'configure' was missed?" % buildtype)

    # Since ant_glob can traverse both source and build folders, it is a best practice
    # to call this method only from the most specific build node
    srcDirNode = ctx.path.find_dir(assist.SRCSYMLINKNAME)

    tasks = ctx.env.alltasks[buildtype]
    for taskName, taskParams in tasks.items():
        # task env variables are stored in separative env so it's need to switch in
        ctx.variant = taskParams['task-build-env']
        kwargs = dict(
            name     = taskName,
            target   = tools.makeTargetPath(ctx, buildtype, taskParams.get('target', '')),
            features = taskParams.get('features', ''),
            lib      = taskParams.get('sys-libs', []),
            libpath  = taskParams.get('sys-lib-path', []),
            rpath    = taskParams.get('rpath', []),
            use      = taskParams.get('use', []),
            vnum     = taskParams.get('ver-num', ''),
        )

        src = taskParams.get('source', None)
        if src:
            kwargs['source'] = srcDirNode.ant_glob(
                incl       = src.get('include', ''),
                excl       = src.get('exclude', ''),
                ignorecase = src.get('ignorecase', False),
                generator = True)

        # Includes paths are given relative to the directory containing the wscript file.
        # Providing absolute paths are best avoided as they are a source of portability problems.
        includes = taskParams.get('includes', None)
        if includes:
            if isinstance(includes, assist.string_types):
                includes = includes.split()
            includes = [ x if os.path.isabs(x) else _joinpath(assist.SRCSYMLINKNAME, x) for x in includes ]
            kwargs['includes'] =  includes

        # create build task generator
        ctx(**kwargs)

    # It's neccesary to revert to origin variant otherwise WAF won't find
    # correct path at the end of building step.
    ctx.variant = buildtype
