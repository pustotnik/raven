#!/usr/bin/env python
# coding=utf8
#

"""
 Copyright (c) 2019, Alexander Magola. All rights reserved.
 license: BSD, see LICENSE for more details.
"""

import sys, os

_joinpath  = os.path.join
_abspath   = os.path.abspath

from waflib import Configure, Build, Options, Context, Logs
from waflib.ConfigSet import ConfigSet

# Avoid writing .pyc files
sys.dont_write_bytecode = True
import buildconf
sys.dont_write_bytecode = False
import assist

confHandler = None

# these variables are mandatory ('/' are converted automatically)
top = assist.BUILDROOT
out = assist.BUILDOUT

# mostly for WAF 'dist' command
APPNAME = buildconf.project['name']
VERSION = buildconf.project['version']

def options(opt):

    # This method WAF calls before all other methods including 'init'

    global confHandler
    confHandler = assist.BuildConfHandler(buildconf)

    # Remove incompatible options
    opt.parser.remove_option('-o')
    opt.parser.remove_option('-t')

    # TODO: add support for several builtypes
    #opt.add_option('-b', '--buildtype', action = 'append', 
    #                choices = confHandler.supportedBuildTypes,
    #                default = [confHandler.defaultBuildType],
    #                help = 'set the build type')

    opt.add_option('-b', '--buildtype', action = 'store', 
                    choices = confHandler.supportedBuildTypes,
                    default = confHandler.defaultBuildType,
                    help = 'set the build type')

    #opt.load('compiler_cxx')

def init(ctx):

    from copy import deepcopy
    assist.wafcommands = deepcopy(Options.commands)

    confHandler.handleCmdLineArgs()

    from waflib.Build import BuildContext, CleanContext, InstallContext, UninstallContext
    for buildtype in confHandler.selectedBuildTypes:
        for c in (BuildContext, CleanContext, InstallContext, UninstallContext):
            class CtxClass(c):
                variant = buildtype

def configure(ctx):

    #ctx.load('compiler_cxx')

    # make independent copy of root env
    rootEnv   = assist.deepcopyEnv(ctx.env)
    buildtype = confHandler.realBuildType(Options.options.buildtype)
    toolchainEnv = {}

    def loadToolchain(toolchain):
        if toolchain not in toolchainEnv:
            ctx.setenv(toolchain, env = rootEnv)
            ctx.load(toolchain)
            toolchainEnv[toolchain] = ctx.all_envs[toolchain]

    # Examples of setings from environment:
    # CC=clang CXX=clang++
    buildByToolFromEnv = False
    #TODO: add others
    toolchainEnvVars = ('CC', 'CXX')
    for var in toolchainEnvVars:
        if var in os.environ:
            buildByToolFromEnv = True
            loadToolchain(os.environ[var])
            # TODO: add loading of LINK_CC, LINK_CXX, AR, ?
            # LINK_CC = CC, LINK_CXX = CXX ?

    # special mode when toolchain is set by env var
    if buildByToolFromEnv:
        buildtype = ''
        # task params must not have compiler/linker flags from 'buildtypes' 
        # TODO
    
    for toolchain in confHandler.toolchainNames(buildtype):
        loadToolchain(toolchain)

    # switch to root env due to calls of 'loadToolchain'
    ctx.setenv('')

    ctx.env.alltasks = assist.loadTasksFromCache()
    tasks = confHandler.tasks(buildtype)
    ctx.env.alltasks[buildtype] = tasks

    for taskName, taskParams in tasks.items():
        # make variant for each task: 'buildtype.taskname'
        taskVariant = assist.getTaskVariantName(buildtype, taskName)
        # store it
        taskParams['task-build-env'] = taskVariant

        # set up env each type of toolchain for tasks
        toolchain = taskParams.get('toolchain', None)
        parentEnv = toolchainEnv.get(toolchain, rootEnv)
        parentEnv = assist.copyEnv(parentEnv)

        # and switch to selected env
        ctx.setenv(taskVariant, env = parentEnv)

        # set variables
        assist.setTaskEnvVars(ctx.env, taskParams)

        # Waf always loads all *_cache.py files in directory 'c4che' during build step. 
        # So it loads all stored variants even though they aren't needed. And I decided 
        # to save variants in different files and load only needed ones.
        ctx.env.store(assist.makeCacheConfFileName(taskVariant))
        # It's necessary to delete variant from ctx.all_envs otherwise waf will store in 'c4che'
        ctx.setenv('')
        del ctx.all_envs[taskVariant]

    #ctx.check(header_name='stdio.h', features='cxx cxxprogram', mandatory=False)
    #ctx.check(header_name='cstdio', features='cxx cxxprogram', mandatory=True)

    # Remove unneccesary envs
    for toolchain in toolchainEnv.keys():
        del ctx.all_envs[toolchain]

    assist.dumpRavenCommonFile()

def build(bld):

    if bld.variant is None:
        bld.fatal('No variant!')

    buildtype = bld.variant
    if buildtype not in bld.env.alltasks:
        bld.fatal("Buildtype '%s' is not found! Was step 'configure' missed?" % buildtype)

    # Since ant_glob can traverse both source and build folders, it is a best practice
    # to call this method only from the most specific build node
    srcDirNode = bld.path.find_dir(assist.SRCSYMLINKNAME)

    tasks = bld.env.alltasks[buildtype]
    for taskName, taskParams in tasks.items():
        # task env variables are stored in separative env so it's need to switch in
        bld.variant = taskParams['task-build-env']
        # load environment for this task
        bld.all_envs[bld.variant] = ConfigSet(assist.makeCacheConfFileName(bld.variant))
        
        target = taskParams.get('target', taskName)
        kwargs = dict(
            name     = taskName,
            target   = assist.makeTargetPath(bld, buildtype, target),
            features = taskParams.get('features', ''),
            lib      = taskParams.get('sys-libs', []),
            libpath  = taskParams.get('sys-lib-path', []),
            rpath    = taskParams.get('rpath', []),
            use      = taskParams.get('use', []),
            vnum     = taskParams.get('ver-num', ''),
        )

        src = taskParams.get('source', None)
        if src:
            kwargs['source'] = srcDirNode.ant_glob(
                incl       = src.get('include', ''),
                excl       = src.get('exclude', ''),
                ignorecase = src.get('ignorecase', False),
                generator = True)

        includes = assist.handleTaskIncludesParam(taskParams)
        if includes:
            kwargs['includes'] =  includes

        # create build task generator
        bld(**kwargs)

    # It's neccesary to revert to origin variant otherwise WAF won't find
    # correct path at the end of building step.
    bld.variant = buildtype
